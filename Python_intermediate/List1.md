[TOC]

## LIST - 1

#### 1. 알고리즘

##### 1. 알고리즘 개요

- 알고리즘

  - 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
  - 어떠한 문제를 해결하기 위한 절차

  > 1 ~ 100 을 모두 더하는 과정을 생각해보면,
  >
  > 1 + 2 + ... + 100 으로 할 수 있지만
  >
  > (1+100) + (2+99) + ... + (100+1) / 2 = 5050으로 표현할 수 있는데,
  >
  > 이런 것을 알고리즘이라 할 수 있다.

- 알고리즘 표현법

  - 슈도 코드

    **일반적인 언어**로 코드를 흉내 내어 알고리즘을 써 놓은 코드

    컴퓨터에서 실행할 수 없고, 연습하는데 사용한다.

    ```markdown
    def calcSum(n):
    	sum = 0
    	for i in range(1, n+1):
    		sum = sum + i
    	return sum
    print(clacSum(100))
    ```

  - 순서도

    프로그램이나 작업의 진행 흐름을 순서에 따라 여러 가지 기호나 문자로 나타낸 도표

    프로그램을 작성하기 전 전체 흐름을 파악하기 쉽다

    

##### 2. 알고리즘의 성능 분석

- 무엇이 좋은 알고리즘인가?

  - 정확성

    **얼마나 **정확하게 동작하는가?

  - 작업량

    얼마나 **적은 연산**으로 원하는 결과를 얻어내는가?

  - 메모리 사용량

    얼마나 **적은 메모리**를 사용하는가?

  - 단순성

    얼마나 **단순**한가?

  - 최적성

    더 이상 개선할 여지 없이 **최적화** 되었는가?

- 알고리즘의 성능 분석 필요

  많은 문제에서 분석 기준으로 알고리즘의 작업량을 비교

  > 위의 1 ~ 100 을 더하는 과정을 생각해보면
  >
  > 1. 99번의 덧셈
  > 2. 덧셈 1번, 곱셈 1번, 나눗셈 1번 => 3번
  >
  > 즉, 월등히 차이가 난다

  실제 걸리는 시간을 측정하거나

  실행되는 명령문의 개수를 계산 => 시간복잡도 계산에 주로 사용된다.

- 시간 복잡도 = 빅 - 오 (O) 표기법

  시간 복잡도 함수 중에서 가장 큰 영향력을 주는 **n에 대한 항**만을 표시

  **계수는 생략**하여 표시

  ```markdown
  O(2n + 1) = O(2n) = O(n)
  => 최고차항만 선택 => 계수 2 제거
  O(2n^2 + 10n + 100) = O(n^2)
  O(4) = O(1)
  상수는 10000과 1이여도 동일한 시간 복잡도를 가진다고 본다.
  위의 형식으로 생각할 수 있다.
  ```



#### 2. Exhaustive Search

##### 1. 완전 검색 소개

- 완전 검색(Exhaustive Search)

  문제의 해법으로 생각할 수 있는 **모든 경우의 수를 나열해보고 확인**

  1. **Brute_force** 혹은 Generate-and-Test 라고도 불림
  2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
  3. 일반적으로 경우의 수가 작을 때 유용
  4. 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다
  5. 우선 **완전 검색으로 해답을 도출**한 뒤, **다른 알고리즘을 적용**하여 **효율성을 높이는 과정**이 바람직하다



#### 3. Greedy Algorithm

